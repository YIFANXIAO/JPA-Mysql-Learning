# 正文



## 一、悲观锁和乐观锁

### 乐观锁

指对于来自外界的修改，持乐观态度。认为数据在一般情况下不会造成冲突，所以只在更新时，才会对数据是否冲突进行检测。

通常的做法如下

~~~
1、数据库表三个字段，分别是id、value、version
select id,value,version from TABLE where id = #{id}

2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作，version代指我们设计的某个标识，也可以是时间戳等
update TABLE
set value=2,version=version+1
where id=#{id} and version=#{version}
~~~



### 悲观锁

指对于来自外界（对于数据库来说的外界）的修改持悲观态度。所以，在整个数据处理过程当中，将数据处于锁定状态

悲观锁的实现，往往需要依赖数据库进行实现。（例如数据库级别的排他锁。否则即便在本系统中实现了悲观锁，也无法保证外部系统可能会进行的修改）

**对于悲观锁这个概念，其实又可以引申出来两种锁，分别是共享锁和排他锁**



#### 共享锁

又称”读锁“，是针对于读取操作而创建的锁。在共享锁状态下，数据的"版本"会被锁定，使用户可以并发的进行读取数据。

共享锁和排他锁互斥，也就是说，在共享锁生效期间，是不可以对数据进行任何修改（insert、update、delete）



#### 排他锁

又称”写锁“，相对于共享锁，程度更深。在排他锁状态下，数据”版本“锁定，除当前事务外，其他事物对于锁定的数据，只可以读取，不能进行修改，只有等待当前锁释放。

排他锁会阻塞所有的排他锁和共享锁。



#### autocommit

在数据库中想要使用排他锁，首先需要关闭innoDB默认的自动提交

在自动提交模式下，update、insert和delete都是会默认以排他锁的方式执行，单独的语句就是一个事物。



## 二、mysql innoDB中悲观锁的机制

### 行锁和表锁

行锁和表锁指的是在innoDB当中对应数据加锁的两种形式

特点：

| 类别 | 并发度 | 开销           | 是否会死锁 |
| ---- | ------ | -------------- | ---------- |
| 行锁 | 最高   | 开销大，加锁慢 | 会         |
| 表锁 | 最低   | 开销小，加锁快 | 不会       |



什么时候使用表锁或行锁，由InnoDB控制

机制：

**InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。**



极端情况举例：

当你去更新一张表的大部分数据或者全表数据时，即便使用了索引进行更新。

mysql此时也会认为，此时对于每行数据单独添加行锁的开销过大，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突问题，性能严重下降。所以MySQL会将行锁升级为表锁，即实际上并没有使用索引。



**行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。**



#### 间隙锁

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。



InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。



## 三、JPA的实现



### 乐观锁推荐实现方式：

#### @Version注解

在实体类当中，标注某个属性为版本控制属性即可。这样之后，再使用save方法等，就会自动去更新版本控制属性



注意，可以添加@Version注解的属性必须满足以下条件：

- 每个实体类别必须只有一个版本属性
- 对于映射到多个表的实体，必须将其放置在主表中
- 版本属性的类型必须是以下之一：*int*，*Integer*，*long*，*Long*，*short*，*Short*，*java.sql.Timestamp*



### 悲观锁推荐实现方式：

#### LockModeType

是JPA定义的一个用来标注，事务锁的一个枚举类型。

```
		//和OPTIMISTIC同义
		READ,
		//和OPTIMISTIC_FORCE_INCREMENT同义
    WRITE,
		// 乐观锁
    OPTIMISTIC,
		// 乐观锁，同时更新版本控制属性
    OPTIMISTIC_FORCE_INCREMENT,
		// 共享锁
    PESSIMISTIC_READ,
		// 排他锁
    PESSIMISTIC_WRITE,
		// 同义PESSIMISTIC_WRITE，但会更新Version字段
    PESSIMISTIC_FORCE_INCREMENT,

    NONE
```



推荐在repo方法上添加Lock注解，指定不同的锁。

```
// 自定义查询方法，这里必须使用JPQL，不可以使用原生sql
// 需要指定在事务当中执行
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT c FROM Customer c WHERE c.orgId = ?1")
public List<Customer> fetchCustomersByOrgId(Long orgId);

// 直接添加在默认方法上，不过需要显式对方法进行声明
@Lock(LockModeType.PESSIMISTIC_READ)
public Optional<Customer> findById(Long customerId);
```





## 四、场景列举



### 什么场景下用表锁

第一种情况：全表更新。事务需要更新大部分或全部数据，且表又比较大。若使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突。

第二种情况：多表查询。事务涉及多个表，比较复杂的关联查询，很可能引起死锁，造成大量事务回滚。这种情况若能一次性锁定事务涉及的表，从而可以避免死锁、减少数据库因事务回滚带来的开销。

1. InnoDB 支持表锁和行锁，使用索引作为检索条件修改数据时采用行锁，否则采用表锁。
2. InnoDB 自动给修改操作加锁，给查询操作不自动加锁
3. 行锁可能因为未使用索引而升级为表锁，所以除了检查索引是否创建的同时，也需要通过explain执行计划查询索引是否被实际使用。
4. 行锁相对于表锁来说，优势在于高并发场景下表现更突出，毕竟锁的粒度小。
5. 当表的大部分数据需要被修改，或者是多表复杂关联查询时，建议使用表锁优于行锁。
6. 为了保证数据的一致完整性，任何一个数据库都存在锁定机制。锁定机制的优劣直接影响到一个数据库的并发处理能力和性能。

mysql 5.6 在 update 和 delete 的时候，where 条件如果不存在索引字段，那么这个事务是否会导致表锁？ 有人回答： 只有主键和唯一索引才是行锁，普通索引是表锁。

结果发现普通索引并不一定会引发表锁，在普通索引中，是否引发表锁取决于普通索引的高效程度。

上文提及的“高效”是相对主键和唯一索引而言，也许“高效”并不是一个很好的解释，只要明白在一般情况下，“普通索引”效率低于其他两者即可。 属性值重复率高



[场景列举]: https://juejin.cn/post/6844903668571963406#heading-16

等